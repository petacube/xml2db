# An AttributeTree is a class which allows easy manipulation of attribute trees
# produced by phase one of the algorithm. This is a wrapper allowing
# programatic access to the text elements generated by the original process.
class AttributeTree
  PARENT_PREFIX = "PARENT:"
  attr_reader :root, :relations

  # Reads in the text of an attribute tree an constructs the necessary internal
  # data structures
  def initialize(rels = [])
   @pks_to_relations = Hash.new
   @id_to_relation = Hash.new
   @relations = rels

   rels.each do |r|
     @root = r if  r.parent.nil?
     r.pks.each { |pk| @pks_to_relations[pk] = r }
     @id_to_relation[r.id] = r
     r.tree = self
   end
   initialize_relations unless rels.empty?
  end

  def self.from_file(filename)
    text = File.read(filename)
    AttributeTree.from_text(text)
  end

  def self.from_text(text)
    AttributeTree.new.tap do |at|
      at.from_text(text)
    end
  end

  def from_text(text)
    # Remove any metadata that might be at the beginning of the file (anything
    # before the first parent is ignored)
    lines = text.split("\n").map(&:strip).drop_while do |line|
      !line.start_with? PARENT_PREFIX
    end

    # Remove all blank lines
    lines.reject! { |line| line.match(/\A\s*\Z/) }
    current_pks = Array.new
    current_attributes = Array.new
    lines.each do |line|
      attributes = line_to_attributes(line)

      # Whenever a parent is seen, start a new table
      if line.start_with? PARENT_PREFIX
        create_relation(current_pks, current_attributes)
        current_attributes = Array.new
        current_pks = attributes
      end

      current_attributes.concat(attributes)
    end

    create_relation(current_pks, current_attributes)
    initialize_relations
  end

  # Returns the list of candidate keys represented within the attribute tree
  def candidate_keys
    @pks_to_relations.keys
  end

  # Takes a PK and returns a list of all attributes that are transitively
  # dependent on that PK
  def closure(candidate_name)
    unless @pks_to_relations.has_key?(candidate_name)
      raise ArgumentError, "Cannot find relation w/ pk #{candidate_name}"
    end

    closure = Set.new
    seen = Set.new
    to_explore = [candidate_name]

    until to_explore.empty?
      current = to_explore.pop
      next if seen.include?(current)
      seen << current

      current_relation = @pks_to_relations[current]
      next unless current_relation
      current_attributes = current_relation.attributes

      to_explore += current_attributes
      closure += current_attributes
    end

    closure.to_a
  end

  # Returns true if child is a descendant attribute of parent
  def descendant_of?(parent, child)
    closure(parent).include?(child)
  end

  # Returns the relation associated with that PK
  def pk_to_relation(field)
    if @pks_to_relations.key?(field)
      @pks_to_relations[field]
    else
      nil
    end
  end

  def id_to_relation(id)
    @id_to_relation[id]
  end

  # Yields nodes to the provided block in a BFS order.
  def breadth_first_traversal(&action)
    queue = [@root]
    until queue.empty?
      current_rel = queue.shift
      action.call(current_rel)

      new_rels = Set.new
      current_rel.attributes.each do |attr|
        rel = pk_to_relation(attr)
        if !rel.nil? && rel != current_rel
          new_rels << rel
        end
      end

      queue.unshift(*new_rels.to_a)
    end
  end

  # Creates an exact copy of the attribute tree, that maintains separate
  # data structures for all fields
  def clone
    rels = @relations.map(&:clone)
    AttributeTree.new(rels)
  end

  # Safely moves attributes from src to dest
  #
  # Performs validation to ensure the move is legal
  #
  # If the move takes the whole PK with it, children get hoisted up
  def move(src, dest, attributes)
    puts "Moving #{attributes} to #{dest}"
    if src.tree.object_id != self.object_id
      raise ArgumentError, "Source must be in this tree"
    elsif  dest.tree.object_id != self.object_id
      raise ArgumentError, "Dest must be in this tree"
    elsif src.nil? || dest.nil?
      raise ArgumentError, "Source/Dest cannot be nil"
    elsif src == dest
      raise ArgumentError, "Source must not equal dest: #{src.pks} = #{dest.pks}"
    elsif !(attributes - src.attributes).empty?
      raise ArgumentError, "Source must contain all attributes"
    end

    pks = []                      #attrs from the list that are pks
    attributes.each do |attr|
      rel = pk_to_relation(attr)
      next if rel.nil?

      # Make sure that this isn't the PK for something else. Only allow
      # moves of PKs from their relation itself
      if rel != src
        raise ArgumentError, "Cannot move PKS of other relations indirectly"
      end

      pks << attr
      @pks_to_relations.delete(attr)
    end

    if (src.pks - pks).empty?           #destroy the relation & adjust children
      @relations.reject! { |r| r == src }
      children = @relations.select { |r| r.parent == src }
      children.each do |c|
        c.parent = src.parent
      end

      remaining = src.attributes - attributes
      src.parent.add_attributes(remaining)
      @id_to_relation.delete(src.id)
    end

    # Actually perform the move
    src.remove_attributes(attributes)
    if src.parent                           #PKs will appear in parents
      src.parent.remove_attributes(attributes)
    end
    dest.add_attributes(attributes)

    calculate_depths
  end

  # Removes a relation AND ALL OF ITS DESCENDANTS from the attribute tree
  def delete_relation(rel)
    unless @id_to_relation.key?(rel.id)
      raise "Relation doesn't exist in tree"
    end

    to_remove = [rel]
    until (target = to_remove.pop).nil?
      target.attributes.each do |attr|
        next_rel = pk_to_relation(attr)

        if !next_rel.nil?
          to_remove << next_rel
        end
      end

      target.pks.each { |pk| @pks_to_relations.delete(pk) }
      @id_to_relation.delete(target.id)
      @relations.delete(target)
    end

    initialize_relations
  end

  private
  # Casts a line from the file to a list of attribute names
  def line_to_attributes(line)
    line.gsub(PARENT_PREFIX, "").split(",").map(&:strip)
  end

  # Constructs a relation and binds it into the pk -> relation data structures
  def create_relation(pks, attributes)
    return if pks.empty?

    rel = Relation.new(pks, attributes, self)
    pks.each { |pk| @pks_to_relations[pk] = rel }
    @id_to_relation[rel.id] = rel

    if @root.nil?
      @root = rel
    end

    @relations << rel
    rel
  end

  # Populates 1) the depths and 2) the parents inside of the relation objects
  #
  # Perform this after initializing all the nodes, as there order of
  # the input file makes no guarantees about the input order
  def initialize_relations
    @root.parent = nil

    stack = [@root]
    until stack.empty?
      cur_rel = stack.pop

      # Prevents cycles from occurring as a result of multiple attrs
      # mapping into the same relation
      non_pk_attrs = cur_rel.attributes - cur_rel.pks

      non_pk_attrs.each do |attr|
        child_rel = pk_to_relation(attr)
        if child_rel
          child_rel.parent = cur_rel
          stack.push(child_rel)
        end
      end
    end

    calculate_depths
  end

  def calculate_depths
    @root.depth = 0
    stack = [@root]
    until stack.empty?
      cur_rel = stack.pop
      non_pk_attrs = cur_rel.attributes - cur_rel.pks

      non_pk_attrs.each do |attr|
        child_rel = pk_to_relation(attr)
        if child_rel
          child_rel.depth = cur_rel.depth + 1
          stack.push(child_rel)
        end
      end
    end
  end
end
